<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>D-Rock</title>
  <meta name="description" content="AI DJ. Voice only.">
  <meta name="theme-color" content="#0a0a0a">
  <link rel="manifest" href="/manifest.json">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Righteous&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg: #0a0a0a;
      --surface: #111;
      --text: #f0f0f0;
      --dim: #555;
      --accent: #00ff88;
      --cyan: #00d4ff;
      --red: #ff3344;
      --pink: #ff2266;
      --mono: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    }

    @property --hue1 { syntax: '<number>'; initial-value: 190; inherits: false; }
    @property --hue2 { syntax: '<number>'; initial-value: 340; inherits: false; }
    @property --hue3 { syntax: '<number>'; initial-value: 260; inherits: false; }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: var(--mono);
      height: 100vh;
      height: 100dvh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* ===========================
       TURNTABLE AREA — top 2/3
       =========================== */
    .turntable {
      flex: 1;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 0;
      background:
        linear-gradient(145deg, #2a2a2e 0%, #1e1e21 40%, #28282c 70%, #1c1c1f 100%);
      /* Brushed metal texture */
      background-size: 100% 100%;
      transition: opacity 0.4s ease;
    }

    .turntable::before {
      content: '';
      position: absolute;
      inset: 0;
      background:
        repeating-linear-gradient(
          90deg,
          transparent,
          transparent 1px,
          rgba(255,255,255,0.008) 1px,
          rgba(255,255,255,0.008) 2px
        );
      pointer-events: none;
    }

    /* === RECORD === */
    .platter {
      position: relative;
      width: min(92vw, 70vh, 540px);
      height: min(92vw, 70vh, 540px);
    }

    .record {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background:
        radial-gradient(circle, #222 0%, #222 12%, transparent 12.5%),
        radial-gradient(circle, #111 14%, transparent 14.5%),
        repeating-radial-gradient(
          circle,
          rgba(255,255,255,0.03) 0px,
          rgba(255,255,255,0.03) 1px,
          transparent 1px,
          transparent 4px
        ),
        conic-gradient(from 0deg, #0a0a0a, #111, #0a0a0a, #0f0f0f, #0a0a0a, #111, #0a0a0a);
      position: relative;
      box-shadow:
        0 2px 20px rgba(0,0,0,0.6),
        0 0 60px rgba(0,0,0,0.3);
    }

    .record.spinning { animation: spin 2s linear infinite; }
    .record.spinning-slow { animation: spin 8s linear infinite; }

    @keyframes spin { to { transform: rotate(360deg); } }

    /* Groove rings — electric ambient color */
    .record::before {
      content: '';
      position: absolute;
      inset: 6%;
      border-radius: 50%;
      background:
        radial-gradient(circle,
          transparent 0%, transparent 24%,
          hsla(var(--hue1), 100%, 65%, 0.35) 26%, transparent 28%,
          hsla(var(--hue2), 95%, 60%, 0.20) 33%, transparent 35%,
          hsla(var(--hue3), 100%, 58%, 0.30) 39%, transparent 41%,
          hsla(var(--hue1), 95%, 62%, 0.18) 46%, transparent 48%,
          hsla(var(--hue2), 100%, 60%, 0.28) 52%, transparent 54%,
          hsla(var(--hue3), 95%, 58%, 0.15) 59%, transparent 61%,
          hsla(var(--hue1), 100%, 65%, 0.25) 66%, transparent 68%,
          hsla(var(--hue2), 95%, 60%, 0.18) 73%, transparent 75%,
          hsla(var(--hue3), 100%, 58%, 0.30) 80%, transparent 82%,
          hsla(var(--hue1), 95%, 65%, 0.20) 87%, transparent 89%,
          hsla(var(--hue2), 100%, 62%, 0.35) 94%, transparent 96%
        );
      pointer-events: none;
      animation: grooveShift 12s ease-in-out infinite;
    }

    /* Second layer — glow bleed */
    .record::after {
      content: '';
      position: absolute;
      inset: 10%;
      border-radius: 50%;
      background:
        radial-gradient(circle,
          transparent 0%, transparent 30%,
          hsla(var(--hue2), 100%, 65%, 0.12) 40%,
          transparent 50%,
          hsla(var(--hue1), 100%, 65%, 0.10) 60%,
          transparent 70%,
          hsla(var(--hue3), 100%, 65%, 0.12) 85%,
          transparent 95%
        );
      pointer-events: none;
      animation: grooveShift 12s ease-in-out infinite;
      animation-delay: -4s;
      filter: blur(6px);
    }

    @keyframes grooveShift {
      0%   { --hue1: 190; --hue2: 340; --hue3: 260; }
      25%  { --hue1: 260; --hue2: 30;  --hue3: 190; }
      50%  { --hue1: 340; --hue2: 160; --hue3: 30;  }
      75%  { --hue1: 30;  --hue2: 260; --hue3: 340; }
      100% { --hue1: 190; --hue2: 340; --hue3: 260; }
    }

    /* Center label */
    .label {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 42%;
      height: 42%;
      border-radius: 50%;
      background: radial-gradient(circle, #1a1a1a 60%, #111 100%);
      border: 2px solid #222;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    /* DROCK text row — the O is the hole */
    .label-word {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: clamp(0.4rem, 1.7vw, 0.85rem);
      font-family: 'Righteous', sans-serif;
      font-weight: 400;
      font-size: clamp(1.1rem, 4.6vw, 2.2rem);
      color: #777;
      line-height: 1;
      text-transform: uppercase;
    }

    .label-letter {
      display: block;
    }

    /* The D — emphasis so it reads D ROCK not DR OCK */
    .label-d {
      display: block;
      color: #999;
      margin-right: clamp(0.15rem, 0.6vw, 0.3rem);
    }

    /* The O — spindle hole */
    .label-hole {
      display: block;
      width: 0.7em;
      height: 0.7em;
      border-radius: 50%;
      border: 0.14em solid #777;
      background: var(--bg);
      position: relative;
      flex-shrink: 0;
      margin-top: 0.03em;
    }

    .label-hole::after {
      content: '';
      width: 3px;
      height: 3px;
      border-radius: 50%;
      background: #444;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .label-sub {
      font-family: var(--mono);
      font-size: clamp(0.35rem, 1vw, 0.5rem);
      color: var(--cyan);
      text-transform: uppercase;
      letter-spacing: 0.35em;
      position: absolute;
      bottom: 12%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0.6;
    }

    /* === TONEARM === */
    .tonearm {
      position: absolute;
      top: 2%;
      right: 5%;
      width: 45%;
      height: 55%;
      z-index: 10;
      transform-origin: 82% 6%;
      transform: rotate(-30deg);
      pointer-events: none;
    }

    /* Animated needle drop */
    .tonearm.dropping {
      animation: needleDrop 1.8s cubic-bezier(0.22, 0.61, 0.36, 1) forwards;
    }
    .tonearm.playing {
      transform: rotate(16deg);
    }
    .tonearm.lifting {
      animation: needleLift 1s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }

    @keyframes needleDrop {
      0%   { transform: rotate(-30deg); }
      40%  { transform: rotate(18deg); }
      55%  { transform: rotate(14deg); }
      70%  { transform: rotate(17deg); }
      100% { transform: rotate(16deg); }
    }

    @keyframes needleLift {
      0%   { transform: rotate(16deg); }
      100% { transform: rotate(-30deg); }
    }

    .tonearm-base {
      position: absolute;
      top: 0;
      right: 6%;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: radial-gradient(circle, #777, #444);
      border: 2px solid #555;
    }

    .tonearm-line {
      position: absolute;
      top: 6%;
      right: 13%;
      width: 3px;
      height: 78%;
      background: linear-gradient(to bottom, #666, #444);
      transform: rotate(-6deg);
      transform-origin: top center;
      border-radius: 2px;
    }

    .tonearm-head {
      position: absolute;
      bottom: 12%;
      right: 5%;
      width: 14px;
      height: 22px;
      background: #555;
      border-radius: 2px 2px 1px 1px;
      transform: rotate(-6deg);
    }

    .tonearm-head::after {
      content: '';
      position: absolute;
      bottom: -4px;
      left: 50%;
      transform: translateX(-50%);
      width: 2px;
      height: 6px;
      background: #888;
    }

    /* === STATE LABEL === */
    #state-label {
      position: absolute;
      bottom: 2%;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.65rem;
      color: var(--dim);
      text-transform: uppercase;
      letter-spacing: 0.3em;
      white-space: nowrap;
    }

    /* === SPOTIFY CONNECT === */
    #spotify-connect {
      position: absolute;
      bottom: 2%;
      left: 50%;
      transform: translateX(-50%);
      padding: 0.4rem 0.8rem;
      background: transparent;
      border: 1px solid #666;
      color: #888;
      font-family: var(--mono);
      font-size: 0.55rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      cursor: pointer;
      z-index: 5;
    }
    #spotify-connect:hover { background: #888; color: var(--bg); }
    #spotify-connect.connected { display: none; }

    /* ===========================
       BOTTOM PANEL — board + input
       =========================== */
    .bottom-panel {
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: linear-gradient(180deg, #1c1c1f 0%, #151517 100%);
      border-top: 1px solid #333;
      padding-bottom: env(safe-area-inset-bottom, 0);
    }

    /* Now Playing */
    #now-playing {
      padding: 0.5rem 0;
      display: none;
      align-items: center;
      gap: 0.75rem;
      border-bottom: 1px solid #1a1a1a;
      width: min(92vw, 70vh, 540px);
    }
    #np-art { width: 36px; height: 36px; background: #1a1a1a; flex-shrink: 0; }
    #np-art img { width: 100%; height: 100%; object-fit: cover; }
    #np-title { font-size: 0.7rem; font-weight: 700; }
    #np-artist { font-size: 0.6rem; color: var(--dim); }

    /* EQ */
    .eq-wrap {
      display: flex;
      align-items: flex-end;
      justify-content: center;
      gap: 2px;
      height: 36px;
      padding: 0.5rem 0 0;
      width: min(92vw, 70vh, 540px);
    }

    .eq-bar {
      width: 5px;
      border-radius: 2px 2px 0 0;
      transition: height 0.1s ease;
      height: 3px;
      opacity: 0.7;
    }
    .eq-bar.hot { opacity: 1; }

    /* Input bar */
    .input-bar {
      display: flex;
      align-items: center;
      border-top: 1px solid #1a1a1a;
      width: min(92vw, 70vh, 540px);
    }

    #mic-btn {
      width: 48px;
      height: 48px;
      background: transparent;
      border: none;
      border-right: 1px solid #1a1a1a;
      color: var(--dim);
      font-size: 1rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      -webkit-tap-highlight-color: transparent;
      transition: color 0.2s, background 0.2s;
      flex-shrink: 0;
    }
    #mic-btn:hover { color: var(--text); }
    #mic-btn.listening { color: var(--red); background: rgba(255,51,68,0.1); }
    #mic-btn.thinking { color: var(--accent); }
    #mic-btn.speaking { color: var(--accent); background: rgba(0,255,136,0.05); }
    #mic-btn:disabled { opacity: 0.3; cursor: not-allowed; }

    #text-input {
      flex: 1;
      background: transparent;
      border: none;
      color: var(--text);
      font-family: var(--mono);
      font-size: 0.75rem;
      padding: 0.9rem;
      outline: none;
    }
    #text-input::placeholder { color: #666; }

    #send-btn {
      width: 48px;
      height: 48px;
      background: transparent;
      border: none;
      border-left: 1px solid #1a1a1a;
      color: var(--dim);
      font-family: var(--mono);
      font-size: 1rem;
      cursor: pointer;
      flex-shrink: 0;
    }
    #send-btn:hover { color: var(--accent); }

    .safe-bottom {
      height: env(safe-area-inset-bottom, 0);
      background: var(--surface);
    }

    /* ===========================
       LINER NOTES — visual poetry
       =========================== */
    .liner-notes {
      position: fixed;
      inset: 0;
      background: var(--bg);
      z-index: 50;
      overflow: hidden;
      transition: opacity 0.6s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .liner-notes.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .liner-notes.visible {
      opacity: 1;
      pointer-events: auto;
    }

    /* Word elements */
    .poetry-word {
      position: absolute;
      font-family: var(--mono);
      text-transform: lowercase;
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.15s ease;
      will-change: transform, opacity;
    }

    /* Size scale */
    .poetry-size-1 { font-size: clamp(0.55rem, 1.5vw, 0.85rem); }
    .poetry-size-2 { font-size: clamp(0.75rem, 2.5vw, 1.1rem); }
    .poetry-size-3 { font-size: clamp(1rem, 3.5vw, 1.6rem); }
    .poetry-size-4 { font-size: clamp(1.6rem, 6vw, 2.8rem); font-weight: 700; }
    .poetry-size-5 { font-size: clamp(2.2rem, 10vw, 4.5rem); font-weight: 700; }

    /* Mood colors */
    .poetry-mood-dim   { color: hsla(0, 0%, 60%, 0.4); }
    .poetry-mood-punch { color: var(--accent); }
    .poetry-mood-warm  { color: hsl(38, 90%, 58%); }
    .poetry-mood-cold  { color: hsla(195, 100%, 50%, 0.7); }
    .poetry-mood-ghost { color: hsla(0, 0%, 100%, 0.1); }
    .poetry-mood-burn  { color: var(--pink); }

    /* Entry animation */
    @keyframes poetryFadeIn {
      from { opacity: 0; transform: translateY(8px); }
      to   { opacity: 1; transform: translateY(0); }
    }

    @keyframes poetryFadeOut {
      from { opacity: 1; }
      to   { opacity: 0; }
    }

    .poetry-word.entering {
      animation: poetryFadeIn 0.8s cubic-bezier(0.22, 0.61, 0.36, 1) forwards;
    }

    .poetry-word.exiting {
      animation: poetryFadeOut 1s ease forwards;
    }

    /* Audio-reactive pulse */
    .poetry-word.pulse {
      transition: transform 0.1s ease;
    }

    /* Mode toggle button */
    .mode-toggle {
      position: fixed;
      top: env(safe-area-inset-top, 12px);
      right: 12px;
      z-index: 100;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 1px solid #333;
      background: rgba(10, 10, 10, 0.8);
      color: var(--dim);
      font-size: 1rem;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      -webkit-tap-highlight-color: transparent;
      backdrop-filter: blur(8px);
      transition: color 0.2s, border-color 0.2s;
    }

    .mode-toggle:hover { color: var(--text); border-color: #555; }
    .mode-toggle.active { display: flex; }
  </style>
</head>
<body>

  <!-- === TURNTABLE === -->
  <div class="turntable">
    <div class="platter">
      <div class="record" id="record">
        <div class="label">
          <div class="label-word">
            <span class="label-d">D</span>
            <span class="label-letter">R</span>
            <span class="label-hole"></span>
            <span class="label-letter">C</span>
            <span class="label-letter">K</span>
          </div>
          <span class="label-sub">AI DJ</span>
        </div>
      </div>
    </div>

    <div class="tonearm" id="tonearm">
      <div class="tonearm-base"></div>
      <div class="tonearm-line"></div>
      <div class="tonearm-head"></div>
    </div>

    <p id="state-label"></p>
    <button id="spotify-connect">Connect Spotify</button>
  </div>

  <!-- === LINER NOTES === -->
  <div id="liner-notes" class="liner-notes hidden"></div>

  <!-- === MODE TOGGLE === -->
  <button id="mode-toggle" class="mode-toggle" aria-label="Toggle view">◉</button>

  <!-- === BOTTOM PANEL === -->
  <div class="bottom-panel">
    <div id="now-playing">
      <div id="np-art"></div>
      <div>
        <div id="np-title"></div>
        <div id="np-artist"></div>
      </div>
    </div>

    <div class="eq-wrap" id="eq"></div>

    <div class="input-bar">
      <button id="mic-btn" aria-label="Talk to D-Rock">&#x1f3a4;</button>
      <input type="text" id="text-input" placeholder="play something for a late night drive..." autocomplete="off">
      <button id="send-btn" aria-label="Send">&rarr;</button>
    </div>
  </div>


  <script>
    // --- Config ---
    const SPOTIFY_CLIENT_ID = '';
    const REDIRECT_URI = window.location.origin + '/callback';
    const SCOPES = [
      'user-read-currently-playing',
      'user-read-playback-state',
      'user-modify-playback-state',
      'streaming'
    ].join(' ');

    // --- State ---
    let spotifyToken = sessionStorage.getItem('spotify_token') || null;
    let spotifyDeviceId = null;
    let appState = 'idle';

    // --- View mode state ---
    let currentView = 'turntable'; // 'turntable' | 'liner-notes'
    let viewLocked = false;
    let activeTypography = null;

    // --- Elements ---
    const record = document.getElementById('record');
    const tonearm = document.getElementById('tonearm');
    const micBtn = document.getElementById('mic-btn');
    const stateLabel = document.getElementById('state-label');
    const textInput = document.getElementById('text-input');
    const sendBtn = document.getElementById('send-btn');
    const npCard = document.getElementById('now-playing');
    const npTitle = document.getElementById('np-title');
    const npArtist = document.getElementById('np-artist');
    const npArt = document.getElementById('np-art');
    const connectBtn = document.getElementById('spotify-connect');
    const eqWrap = document.getElementById('eq');
    const linerNotes = document.getElementById('liner-notes');
    const modeToggle = document.getElementById('mode-toggle');

    // --- Build EQ bars ---
    const NUM_BARS = 32;
    const bars = [];
    for (let i = 0; i < NUM_BARS; i++) {
      const bar = document.createElement('div');
      bar.className = 'eq-bar';
      eqWrap.appendChild(bar);
      bars.push(bar);
    }

    // --- EQ animation ---
    let eqActive = false;
    let eqRaf = null;
    let audioContext = null;
    let analyser = null;
    let dataArray = null;

    let ambientHue = 190;
    function tickAmbientHue() {
      ambientHue += 0.3;
      if (ambientHue > 360) ambientHue -= 360;
    }

    function startEqIdle() {
      eqActive = true;
      animateEqIdle();
    }

    function animateEqIdle() {
      if (!eqActive) return;
      bars.forEach((bar, i) => {
        bar.style.height = (2 + Math.random() * 3) + 'px';
        bar.style.background = '#333';
        bar.classList.remove('hot');
      });
      setTimeout(() => requestAnimationFrame(animateEqIdle), 300);
    }

    function animateEqAudio() {
      if (!eqActive || !analyser) return;
      tickAmbientHue();
      analyser.getByteFrequencyData(dataArray);
      const step = Math.floor(dataArray.length / NUM_BARS);
      bars.forEach((bar, i) => {
        const val = dataArray[i * step] || 0;
        const h = Math.max(2, (val / 255) * 36);
        const pct = val / 255;
        const hot = pct > 0.75;
        // Wakes up with color only when audio is playing
        const lum = 30 + pct * 35;
        bar.style.height = h + 'px';
        bar.style.background = hot ? `hsl(${(ambientHue + i * 4) % 360}, 70%, ${lum}%)` : `hsl(0, 0%, ${lum}%)`;
        bar.classList.toggle('hot', hot);
      });
      eqRaf = requestAnimationFrame(animateEqAudio);
    }

    function connectAudioToEq(audioEl) {
      if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 128;
      dataArray = new Uint8Array(analyser.frequencyBinCount);
      const source = audioContext.createMediaElementSource(audioEl);
      source.connect(analyser);
      analyser.connect(audioContext.destination);
      eqActive = true;
      animateEqAudio();
    }

    function stopEqAudio() {
      eqActive = false;
      if (eqRaf) cancelAnimationFrame(eqRaf);
      startEqIdle();
    }

    startEqIdle();

    // --- Typography Engine ---
    class TypographyEngine {
      constructor({ poetry, container, audioElement }) {
        this.poetry = poetry.filter(p => p.visible !== false);
        this.container = container;
        this.audio = audioElement;
        this.words = [];
        this.timeouts = [];
        this.pulseRaf = null;
        this.placed = [];
      }

      start() {
        this.container.innerHTML = '';
        this.words = [];
        this.placed = [];

        // Create DOM elements for each visible phrase
        this.poetry.forEach((phrase, i) => {
          const el = document.createElement('span');
          el.className = `poetry-word poetry-size-${phrase.size || 3} poetry-mood-${phrase.mood || 'dim'}`;
          el.textContent = phrase.words.toLowerCase();
          this.container.appendChild(el);
          this.words.push({ el, phrase, index: i });
        });

        // Position words after they're in DOM so we can measure
        requestAnimationFrame(() => {
          this.positionWords();
          this.scheduleWords();
          this.startPulse();
        });
      }

      positionWords() {
        const cw = this.container.clientWidth;
        const ch = this.container.clientHeight;
        const pad = 20;
        const usableW = cw - pad * 2;
        const usableH = ch - pad * 2;

        // Divide into zones — larger words center, smaller words scatter
        this.words.forEach(({ el, phrase }) => {
          const size = phrase.size || 3;
          let x, y;

          if (size >= 4) {
            // Big words: center area (20-80% of viewport)
            x = pad + usableW * (0.2 + Math.random() * 0.6);
            y = pad + usableH * (0.25 + Math.random() * 0.5);
          } else if (size >= 2) {
            // Medium words: wider spread (10-90%)
            x = pad + usableW * (0.1 + Math.random() * 0.8);
            y = pad + usableH * (0.1 + Math.random() * 0.8);
          } else {
            // Tiny words: edges
            x = pad + usableW * Math.random();
            y = pad + usableH * (Math.random() < 0.5 ? Math.random() * 0.2 : 0.8 + Math.random() * 0.2);
          }

          // Nudge to avoid overlap with placed words
          const rect = el.getBoundingClientRect();
          const elW = rect.width || 100;
          x = Math.min(x, cw - elW - pad);
          x = Math.max(pad, x);

          el.style.left = x + 'px';
          el.style.top = y + 'px';
          this.placed.push({ x, y, w: elW, h: rect.height || 30 });
        });
      }

      scheduleWords() {
        const total = this.words.length;
        if (!total) return;

        // Try to get audio duration, fall back to estimated 200ms per word
        const getDuration = () => {
          if (this.audio && this.audio.duration && isFinite(this.audio.duration)) {
            return this.audio.duration * 1000;
          }
          // Estimate: average spoken phrase ~600ms
          return total * 600;
        };

        const schedule = () => {
          const duration = getDuration();
          // Reserve 15% at the end for words to linger before fade
          const activeWindow = duration * 0.85;
          const interval = activeWindow / total;

          this.words.forEach(({ el }, i) => {
            const delay = i * interval;
            const tid = setTimeout(() => {
              el.classList.add('entering');
            }, delay);
            this.timeouts.push(tid);
          });
        };

        // If audio has metadata, use real duration. Otherwise estimate.
        if (this.audio && this.audio.readyState >= 1) {
          schedule();
        } else if (this.audio) {
          this.audio.addEventListener('loadedmetadata', schedule, { once: true });
          // Fallback if metadata never fires
          const fallback = setTimeout(schedule, 300);
          this.timeouts.push(fallback);
          this.audio.addEventListener('loadedmetadata', () => clearTimeout(fallback), { once: true });
        } else {
          schedule();
        }
      }

      startPulse() {
        if (!analyser || !dataArray) return;

        const pulse = () => {
          if (!this.words.length) return;
          analyser.getByteFrequencyData(dataArray);

          // Average energy across frequency bins
          let sum = 0;
          for (let i = 0; i < dataArray.length; i++) sum += dataArray[i];
          const avg = sum / dataArray.length / 255; // 0-1

          this.words.forEach(({ el, phrase }) => {
            const size = phrase.size || 3;
            // Bigger words pulse more noticeably
            const intensity = 1 + avg * (size >= 4 ? 0.06 : 0.02);
            el.style.transform = `scale(${intensity})`;
          });

          this.pulseRaf = requestAnimationFrame(pulse);
        };

        this.pulseRaf = requestAnimationFrame(pulse);
      }

      stop() {
        // Clear scheduled appearances
        this.timeouts.forEach(t => clearTimeout(t));
        this.timeouts = [];

        // Cancel pulse loop
        if (this.pulseRaf) cancelAnimationFrame(this.pulseRaf);
        this.pulseRaf = null;

        // Fade out all words
        this.words.forEach(({ el }) => {
          el.classList.remove('entering');
          el.classList.add('exiting');
        });

        // Clear after fade
        setTimeout(() => {
          this.container.innerHTML = '';
          this.words = [];
        }, 1100);
      }

      // Generate fallback poetry from plain text
      static fromText(text) {
        const sentences = text.match(/[^.!?]+[.!?]*/g) || [text];
        return sentences.map((s, i) => {
          const trimmed = s.trim();
          if (!trimmed) return null;
          const isLast = i === sentences.length - 1;
          const isFirst = i === 0;
          return {
            words: trimmed,
            size: isLast ? 4 : isFirst ? 2 : 3,
            mood: isLast ? 'punch' : 'dim',
            visible: true,
          };
        }).filter(Boolean);
      }
    }

    // --- View mode management ---
    function showView(view) {
      currentView = view;
      if (view === 'liner-notes') {
        linerNotes.classList.remove('hidden');
        linerNotes.classList.add('visible');
        document.querySelector('.turntable').style.opacity = '0';
        document.querySelector('.turntable').style.pointerEvents = 'none';
      } else {
        linerNotes.classList.remove('visible');
        linerNotes.classList.add('hidden');
        document.querySelector('.turntable').style.opacity = '1';
        document.querySelector('.turntable').style.pointerEvents = 'auto';
      }
    }

    modeToggle.addEventListener('click', () => {
      viewLocked = true;
      showView(currentView === 'turntable' ? 'liner-notes' : 'turntable');
    });

    // --- Tonearm animation ---
    function dropNeedle() {
      tonearm.classList.remove('playing', 'lifting');
      // Force reflow so animation restarts
      void tonearm.offsetWidth;
      tonearm.classList.add('dropping');
      tonearm.addEventListener('animationend', function handler() {
        tonearm.removeEventListener('animationend', handler);
        tonearm.classList.remove('dropping');
        tonearm.classList.add('playing');
      });
    }

    function liftNeedle() {
      tonearm.classList.remove('playing', 'dropping');
      void tonearm.offsetWidth;
      tonearm.classList.add('lifting');
      tonearm.addEventListener('animationend', function handler() {
        tonearm.removeEventListener('animationend', handler);
        tonearm.classList.remove('lifting');
      });
    }

    // --- Spotify OAuth ---
    const hash = window.location.hash.substring(1);
    if (hash) {
      const params = new URLSearchParams(hash);
      const token = params.get('access_token');
      if (token) {
        spotifyToken = token;
        sessionStorage.setItem('spotify_token', token);
        history.replaceState(null, '', window.location.pathname);
      }
    }

    if (spotifyToken) connectBtn.classList.add('connected');

    connectBtn.addEventListener('click', () => {
      if (!SPOTIFY_CLIENT_ID) {
        stateLabel.textContent = 'spotify app not configured yet';
        return;
      }
      window.location.href = `https://accounts.spotify.com/authorize?client_id=${SPOTIFY_CLIENT_ID}&response_type=token&redirect_uri=${encodeURIComponent(REDIRECT_URI)}&scope=${encodeURIComponent(SCOPES)}`;
    });

    // --- State machine ---
    let needleDown = false;

    function setState(s, label) {
      appState = s;
      stateLabel.textContent = label || '';
      micBtn.disabled = s === 'thinking' || s === 'speaking';

      micBtn.className = '';
      if (s === 'listening') micBtn.classList.add('listening');
      if (s === 'thinking') micBtn.classList.add('thinking');
      if (s === 'speaking') micBtn.classList.add('speaking');

      // View mode auto-switching
      if (!viewLocked) {
        if (s === 'speaking') {
          showView('liner-notes');
        } else if (s === 'playing' || s === 'idle') {
          showView('turntable');
        }
      }

      // Show toggle when there's something to toggle between
      if (s === 'speaking' || s === 'playing') {
        modeToggle.classList.add('active');
      } else if (s === 'idle') {
        modeToggle.classList.remove('active');
      }

      // Record
      record.classList.remove('spinning', 'spinning-slow');
      const shouldSpin = s === 'playing' || s === 'thinking' || s === 'speaking';

      if (shouldSpin) {
        record.classList.add('spinning');
        if (!needleDown) {
          dropNeedle();
          needleDown = true;
        }
      } else {
        if (needleDown) {
          liftNeedle();
          needleDown = false;
        }
      }
    }

    // --- Speech recognition ---
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;

    if (SpeechRecognition) {
      recognition = new SpeechRecognition();
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.lang = 'en-US';
      recognition.onresult = (e) => handlePrompt(e.results[0][0].transcript);
      recognition.onerror = () => setState('idle', '');
      recognition.onend = () => { if (appState === 'listening') setState('idle', ''); };
    }

    micBtn.addEventListener('click', () => {
      if (appState === 'listening') {
        recognition?.stop();
        setState('idle', '');
        return;
      }
      if (appState !== 'idle' && appState !== 'playing') return;
      if (recognition) {
        setState('listening', 'listening...');
        recognition.start();
      } else {
        stateLabel.textContent = 'mic not supported — type instead';
      }
    });

    // --- Text input ---
    sendBtn.addEventListener('click', submitText);
    textInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') submitText(); });

    function submitText() {
      const val = textInput.value.trim();
      if (!val || (appState !== 'idle' && appState !== 'playing')) return;
      textInput.value = '';
      handlePrompt(val);
    }

    // --- Core flow ---
    async function handlePrompt(prompt) {
      setState('thinking', 'thinking...');

      let djResponse;
      try {
        const res = await fetch('/.netlify/functions/dj', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prompt }),
        });
        djResponse = await res.json();
      } catch {
        setState('idle', 'something broke. try again.');
        return;
      }

      if (djResponse.text) {
        // Reset view lock for fresh cycle
        viewLocked = false;

        // Prepare poetry data (Haiku annotations or fallback)
        const poetry = Array.isArray(djResponse.poetry) && djResponse.poetry.length
          ? djResponse.poetry
          : TypographyEngine.fromText(djResponse.text);

        setState('speaking', 'd-rock is talking...');
        try {
          const speakRes = await fetch('/.netlify/functions/speak', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text: djResponse.text }),
          });
          if (speakRes.ok) {
            const blob = await speakRes.blob();
            const url = URL.createObjectURL(blob);
            const audio = new Audio(url);
            try { connectAudioToEq(audio); } catch {}

            // Start typography engine
            if (activeTypography) activeTypography.stop();
            activeTypography = new TypographyEngine({
              poetry,
              container: linerNotes,
              audioElement: audio,
            });
            activeTypography.start();

            await new Promise((resolve) => {
              audio.onended = resolve;
              audio.onerror = resolve;
              audio.play();
            });
            URL.revokeObjectURL(url);
            stopEqAudio();

            // Stop typography engine
            if (activeTypography) {
              activeTypography.stop();
              activeTypography = null;
            }
          }
        } catch {}
      }

      if (djResponse.track && spotifyToken) {
        setState('playing', 'spinning...');
        try {
          const searchRes = await fetch('/.netlify/functions/spotify', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              action: 'search',
              query: djResponse.track.query || `${djResponse.track.title} ${djResponse.track.artist}`,
              token: spotifyToken,
            }),
          });
          const trackData = await searchRes.json();
          if (trackData.uri) {
            npTitle.textContent = trackData.name;
            npArtist.textContent = trackData.artist;
            npArt.innerHTML = trackData.image ? `<img src="${trackData.image}" alt="">` : '';
            npCard.style.display = 'flex';
            await fetch('/.netlify/functions/spotify', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ action: 'play', uri: trackData.uri, token: spotifyToken, deviceId: spotifyDeviceId }),
            });
          }
        } catch {}
      }

      setState(npCard.style.display === 'flex' ? 'playing' : 'idle',
        npCard.style.display === 'flex' ? 'spinning...' : '');
    }

    // --- PWA ---
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/service-worker.js');
    }
  </script>
</body>
</html>
